$:.unshift File.join(File.dirname(__FILE__), "..", "lib")
require "small_eigen_collider"

raise "Read the README, and understand this can harm your computer." unless File.exist?("i_understand_the_risks.txt")

$VERBOSE = nil

unfiltered_yaml_filename = "unfiltered_tasks.yml"
filtered_yaml_filename = "tasks.yml"

def determine_output_filename
  # FIXME be able to include the ruby implementation's version
  # FIXME should the output filename be chosen by the program like this?
  ruby_engine = defined?(RUBY_ENGINE) ? RUBY_ENGINE : "unknown_engine"
  output_filename = [ruby_engine, RUBY_VERSION, RUBY_PATCHLEVEL, "output.txt"].join("_")
  output_filename
end

if File.exist?(filtered_yaml_filename)
  task_list = SmallEigenCollider::TaskList.new_using_yaml(filtered_yaml_filename)
  task_list.run_and_log_each_task(determine_output_filename)
elsif File.exist?(unfiltered_yaml_filename)
  # This should only happen if you created an unfiltered task list, and then it crashed
  # and you're trying to re-run it
  task_list = SmallEigenCollider::TaskList.new_using_yaml(unfiltered_yaml_filename)
  task_list.add_filter(:success_only)
  task_list.add_filter(:implementation_dependent)
  task_list.run_and_log_each_task(determine_output_filename)
  task_list.dump_tasks_to_yaml(filtered_yaml_filename)
else
  Timeout.timeout(45, TaskListTimeout) do
    iterations = 500
    unfiltered_task_list = SmallEigenCollider::TaskList.new_using_creator(iterations)
    unfiltered_task_list.dump_tasks_to_yaml(unfiltered_yaml_filename)

    task_list = SmallEigenCollider::TaskList.new_using_yaml(unfiltered_yaml_filename)
    task_list.add_filter(:success_only)
    task_list.add_filter(:implementation_dependent)
    task_list.run_and_log_each_task(determine_output_filename)
    task_list.dump_tasks_to_yaml(filtered_yaml_filename)
  end
end
